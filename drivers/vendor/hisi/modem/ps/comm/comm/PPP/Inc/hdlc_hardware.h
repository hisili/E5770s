

#ifndef __HDLC_HARDWARE_H__
#define __HDLC_HARDWARE_H__

/*****************************************************************************
  1 其他头文件包含
*****************************************************************************/
#include "vos.h"
#include "hdlc_interface.h"
#include "TTFComm.h"
#include "TtfMemoryMap.h"
#if(FEATURE_ON == FEATURE_PPP)
#include "soc_hdlc_interface.h"
#endif

#if (SC_CTRL_MOD_6930_SFT == SC_CTRL_MOD)
#include "hi_syscrg.h"
#endif

#ifdef __cplusplus
    #if __cplusplus
        extern "C" {
    #endif
#endif

#pragma pack(4)

#ifdef FEATURE_HDLC_MASTER
/*****************************************************************************
  2 宏定义
*****************************************************************************/
/* 1.============================================================================================ */

/* definitions of bit basic operations */
#define GET_HIGH_WORD_FROM_DWORD(l)           ((VOS_UINT16)((((VOS_UINT32)(l)) >> 16) & 0xFFFF))
#define GET_LOW_WORD_FROM_DWORD(l)           ((VOS_UINT16)(VOS_UINT32)(l))
#define GET_HIGH_BYTE_FROM_WORD(w)           ((VOS_UINT8)(((VOS_UINT16)(w) >> 8) & 0xFF))
#define GET_LOW_BYTE_FROM_WORD(w)           ((VOS_UINT8)(w))
#define HDLC_MAKE_DWORD(hi,low)    ((VOS_UINT32)(((VOS_UINT16)(low))|(((VOS_UINT32)((VOS_UINT16)(hi)))<<16)))
#define HDLC_MAKE_WORD(hi,low)    ((VOS_UINT16)(((VOS_UINT8)(low))|(((VOS_UINT16)((VOS_UINT8)(hi)))<<8)))

#define GET_BITS_FROM_DWORD(DWord, BitMask) ((DWord) & (BitMask))
#define GET_BITS_FROM_WORD(Word, BitMask) ((Word) & (BitMask))
#define GET_BITS_FROM_BYTE(Byte, BitMask)  ((Byte) & (BitMask))
#define SET_BITS_VALUE_TO_BYTE(ucValue, ucStartBitPosition)     ((VOS_UINT8)((ucValue) << (ucStartBitPosition)))

#define SET_BIT_TO_BYTE(ucByte, ucBitPosition)          ((ucByte) |= (0x01 << (ucBitPosition)))
#define CLEAR_BIT_TO_BYTE(ucByte, ucBitPosition)        ((ucByte) &= ~(0x01 << (ucBitPosition)))

#define SET_BIT_TO_WORD(usWord, ucBitPosition)          ((usWord) |= (0x0001 << (ucBitPosition)))
#define CLEAR_BIT_TO_WORD(usWord, ucBitPosition)        ((usWord) &= ~(0x0001 << (ucBitPosition)))

#define SET_BIT_TO_DWORD(ulDWord, ucBitPosition)        ((ulDWord) |= (0x00000001 << (ucBitPosition)))
#define CLEAR_BIT_TO_DWORD(ulDWord, ucBitPosition)      ((ulDWord) &= ~(0x00000001 << (ucBitPosition)))

#define INSERT_BYTE_LAST(pstMem, pstData, usLen, byte) \
{ \
    pstData[usLen]     = pstData[usLen - 1]; \
    pstData[usLen - 1] = byte; \
    PPP_ZC_SET_DATA_LEN(pstMem, 1); \
}
/* 2.============================================================================================ */

/* definition of bit positions and masks in a register */
/* ========================= 1.hdlc_frm_en (0x10) begin ======================= */
/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器frm_en在bit0;
*/
#define     HDLC_FRM_EN_BITPOS                                      (0UL)

/* ========================= 2.hdlc_def_en (0x60) begin ======================= */
/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器def_en在bit0;
*/
#define     HDLC_DEF_EN_BITPOS                                      (0UL)

/* ========================= 3.hdlc_frm_cfg (0x20) begin ======================= */
/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器frm_in_lli_1dor2d在bit0;
        寄存器frm_acfc在bit1;
*/
#define     HDLC_FRM_IN_LLI_1DOR2D_BITPOS                           (0UL)
#define     HDLC_FRM_ACFC_BITPOS                                    (1UL)
#define     HDLC_FRM_PFC_BITPOS                                     (2UL)

/*
   寄存器frm_pfc(2bits)各值含义:
        00b: 硬件模块添加P域, P域无压缩;
        01b: 硬件模块添加P域, P域压缩;
        11b: 硬件模块不添加P域;
*/
#define     HDLC_PROTOCOL_ADD_WITHOUT_COMPRESS   (0x00)
#define     HDLC_PROTOCOL_ADD_WITH_COMPRESS      (0x01)
#define     HDLC_PROTOCOL_NO_ADD                 (0x03)

/* ========================= 4.hdlc_def_cfg (0x70) begin ======================= */
/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器def_uncompleted_ago在bit0;
        寄存器def_acfc在bit1;
*/
#define     HDLC_DEF_IS_UNCOMPLETED_AGO_BITPOS                      (0UL)
#define     HDLC_DEF_ACFC_BITPOS                                    (1UL)
#define     HDLC_DEF_PFC_BITPOS                                     (2UL)


/* 寄存器frm_protocol(16bits)的MASK表 */
#define     HDLC_FRM_PROTOCOL_MASK                       (0x0000FFFF)

/*
   寄存器def_pfc(2bits)各值含义:
        00b: P域无压缩, 需剥离;
        01b: P域压缩, 需剥离;
        11b: P域不剥离;
*/
#define     HDLC_PROTOCOL_REMOVE_WITHOUT_COMPRESS      (0x00)
#define     HDLC_PROTOCOL_REMOVE_WITH_COMPRESS         (0x01)
#define     HDLC_PROTOCOL_NO_REMOVE                    (0x03)

/* ========================= hdlc_prior_ctrl (0x04) begin ======================= */
/*
   寄存器hdlc_prior_ctrl(2bits)各值含义:
        00b: 谁先被使能则先将谁处理完;
        01b: 下行封装优先级高;
        10b: 上行解封装优先级高;
        11b: 无效;
*/
#define     HDLC_PRIOR_FCFS               (0x00)
#define     HDLC_PRIOR_DL_FRM_HIGHER      (0x01)
#define     HDLC_PRIOR_UL_DEF_HIGHER      (0x02)
#define     HDLC_PRIOR_INVALID            (0x03)

/* ====================== 封装状态寄存器地址 hdlc_frm_status (0x28) begin ====================== */
/* 封装模块状态寄存器地址: 相对偏移地址量0x28 */

/* 寄存器frm_out_seg_num(16bits)的MASK表 */
#define     HDLC_FRM_OUT_SEG_NUM_MASK                       (0x0000FFFF)

/* 寄存器frm_valid_num(8bits)的MASK表 */
#define     HDLC_FRM_VALID_NUM_MASK                         (0x000000FF)

/* 寄存器frm_all_pkt_done(1bit)的MASK表 */
#define     HDLC_FRM_ALL_PKT_DONE_MASK                      (0x00000001)

/* 查询封装状态信息的掩码 */
#define     HDLC_FRM_STATUS_MASK                            (0x00000003)

/*
   寄存器frm_block_done([0]位)各值含义:
        0b: 未完成一套链表数据处理;
        1b: 完成一套链表数据处理;
*/
/*
   寄存器frm_error_index([1]位)各值含义:
        1b: 封装发生错误;
*/
#define     HDLC_FRM_ALL_PKT_DOING                     (0x00)
#define     HDLC_FRM_ALL_PKT_DONE                      (0x01)
#define     HDLC_FRM_STOP_EXCEPTION_OCCUR              (0x02)
#define     HDLC_FRM_DONE_EXCEPTION_OCCUR              (0x03)




/* ======================= 解封装状态寄存器地址dlc_def_status (0x88) begin ===================== */
/* 寄存器dlc_def_status(5bits)的MASK表 */
#define     HDLC_DEFRAMER_BLOCK_STATUS_MASK                     (0x0000001B)

/* 查询解封装状态信息的掩码 */
#define     HDLC_DEF_STATUS_MASK                                (0x0000003B)

/*
   寄存器dlc_def_status(5bits)各值含义:
        000000b: 未完成一组数据处理;
        010000b: 未完成一组数据处理，解封装外部正确帧信息上报空间存满暂停;
        001000b: 未完成一组数据处理, 解封装外部输出存储空间存满暂停;
        000001b: 未完成一组数据处理, 已解出LCP帧, 硬件处于暂停状态;
        000010b: 完成一组数据处理, 但无帧上报;
        000011b: 完成一组数据处理, 且有帧上报;
        1xx0xxb: 有异常发生;
*/
#define     HDLC_DEF_STATUS_DOING                               (0x00)
#define     HDLC_DEF_STATUS_PAUSE_RPT_SPACE_FULL                (0x10)
#define     HDLC_DEF_STATUS_PAUSE_OUTPUT_SPACE_FULL             (0x08)
#define     HDLC_DEF_STATUS_PAUSE_LCP                           (0x01)
#define     HDLC_DEF_STATUS_DONE_WITHOUT_FRAMES                 (0x02)
#define     HDLC_DEF_STATUS_DONE_WITH_FRAMES                    (0x03)

/* 3.============================================================================================ */
/* definition of HDLC module: FRAMER, DEFRAMER */
#define     HDLC_FRM_MODULE                                     (0UL)
#define     HDLC_DEF_MODULE                                     (1UL)

/* definition of PPP Link type */
#define     HDLC_IP_MODE                                        (0UL)
#define     HDLC_PPP_MODE                                       (1UL)

/* 解封装是否有非完整帧标识 */
#define     HDLC_DEF_UNCOMPLETED_NOT_EXIST                      (0x0)
#define     HDLC_DEF_UNCOMPLETED_EXIST                          (0x1)

#define     HDLC_INPUT_PARA_LINK_MAX_SIZE                       (TTF_MAX(TTF_HDLC_DEF_INPUT_PARA_LINK_MAX_NUM, TTF_HDLC_FRM_INPUT_PARA_LINK_MAX_NUM))
#define     HDLC_OUTPUT_PARA_LINK_MAX_SIZE                      (TTF_HDLC_FRM_OUTPUT_PARA_LINK_MAX_NUM)

/* 根据PPP ID获取对应内存，暂时只有一路，填为定值，后续可能有多路 */
#define     HDLC_DEF_GET_UNCOMPLETED_INFO(usPppId)              (&g_stUncompletedInfo)
#define     HDLC_DEF_GET_BUF_INFO(usPppId)                      (g_pstHdlcDefBufInfo)
#define     HDLC_FRM_GET_BUF_INFO(usPppId)                      (g_pstHdlcFrmBufInfo)

/* 解封装输出空间首、尾地址，用于判断是否绕回 */
#define     HDLC_DEF_OUTPUT_BUF_START_ADDR                      ((VOS_UINT8 *)(&g_pstHdlcDefBufInfo->aucOutputDataBuf[0]))
#define     HDLC_DEF_OUTPUT_BUF_END_ADDR                        (HDLC_DEF_OUTPUT_BUF_START_ADDR + TTF_HDLC_DEF_OUTPUT_DATA_BUF_LEN)

/* 轮询封装或解封装完成的次数 */
#ifndef  __UT_CENTER__
#define     HDLC_FRM_MAX_WAIT_RESULT_NUM                        (0xFFFF)
#define     HDLC_DEF_MAX_WAIT_RESULT_NUM                        (0xFFFF)
#else
#define     HDLC_FRM_MAX_WAIT_RESULT_NUM                        (0x01)
#define     HDLC_DEF_MAX_WAIT_RESULT_NUM                        (0x01)
#endif

/* 等待封装或解封装响应中断时间,以毫秒为单位 */
#define     HDLC_FRM_MASTER_INT_TIMER_LEN                       (5000)
#define     HDLC_DEF_MASTER_INT_TIMER_LEN                       (5000)

/* 约定软硬件, 封装一组最多提交1502字节给Framer */
#define     HDLC_FRM_IN_PER_MAX_CNT                             (1502L)
#define     HDLC_FRM_OUT_PER_MAX_CNT                            (3013UL)

/* 解封装最大单个数据长度,规避HDLC BUG,最大长度需要+1 */
#define     HDLC_DEF_IN_PER_MAX_CNT                             (PPP_ZC_MAX_DATA_LEN + 1)
/* 解封装上报每帧最长1502字节, IPv4最长1500字节, PPP模式带上协议字段2字节, 共1502字节 */
#define     HDLC_DEF_OUT_PER_MAX_CNT                            (1502UL)

/* 申请封装目的空间失败定时器时长,单位毫秒 */
#define     HDLC_FRM_TIME_INTERVAL                              (100)

/* 申请封装目的空间失败定时器参数 */
#define     HDLC_FRM_OUTPUT_SPACE_ALLOC_FAIL                    (10)

/* 封装后内存最大值 */
#define     HDLC_FRM_GET_MAX_FRAMED_LEN(usLen)                  (2*usLen + 13)

/* 采用轮询还是中断使能的水线，默认值 */
#define     HDLC_DEF_INTERRUPT_LIMIT_DEFAULT                    (2*1024)
#define     HDLC_FRM_INTERRUPT_LIMIT_DEFAULT                    (2*1024)

/* 采用轮询还是中断使能的水线 */
#if (VOS_OS_VER == VOS_WIN32)
/* PC上无法模拟中断，都使用查询 */
#define     HDLC_DEF_INTERRUPT_LIMIT                            (TTF_HDLC_DEF_INPUT_PARA_LINK_MAX_SIZE + 1)
#define     HDLC_FRM_INTERRUPT_LIMIT                            (TTF_HDLC_FRM_INPUT_PARA_LINK_MAX_SIZE + 1)
#else
#define     HDLC_DEF_INTERRUPT_LIMIT                            (g_stHdlcConfigInfo.ulHdlcDefIntLimit)
#define     HDLC_FRM_INTERRUPT_LIMIT                            (g_stHdlcConfigInfo.ulHdlcFrmIntLimit)
#endif

/* AXI总线读写请求超时的判断值，该值由SoC提供，软件负责配置 */
#define     HDLC_AXI_REQ_TIMEOUT_VALUE                          (255)

/* 解封装错误类型个数 */
#define     HDLC_DEF_MAX_TYPE_CNT                               (7UL)

/* 可维可测申请的内存最大长度，防止因为可维可测申请不到内存导致单板复位 */
#define     HDLC_MNTN_ALLOC_MEM_MAX_SIZE                        (2*1024)

/*
   定义异常信息bit位置:
        bit0代表是否进入异常处理(1是进入异常处理，0是没有进入异常处理);
        bit1代表是否是中断处理(1是中断处理，0是轮询处理);
        bit2代表是否等待信号量超时(1是，0否);
        bit3代表是否轮询超时(1是，0否);
*/
#define     HDLC_EXCEPTION_IND_BITPOS                           (0UL)
#define     HDLC_INTERRUPT_IND_BITPOS                           (1UL)
#define     HDLC_SEM_TIMEOUT_IND_BITPOS                         (2UL)
#define     HDLC_WAIT_STATUS_TIMEOUT_IND_BITPOS                 (3UL)

#if ((FEATURE_OFF == FEATURE_SKB_EXP) || (FEATURE_ON == FEATURE_TTFMEM_CACHE))
#ifdef BSP_CONFIG_HI3630
#define     PPP_HDLC_CACHE_INVALID(data, len)                  dma_map_single(0, data, len, DMA_FROM_DEVICE)
#define     PPP_HDLC_CACHE_FLUSH(data, len)					   dma_map_single(0, data, len, DMA_TO_DEVICE)
#else
#define     PPP_HDLC_CACHE_INVALID(data, len)                  __dma_single_dev_to_cpu_nocheck(data, len, DMA_FROM_DEVICE)
#define     PPP_HDLC_CACHE_FLUSH(data, len)                    __dma_single_cpu_to_dev_nocheck(data, len, DMA_TO_DEVICE)
#endif
#endif

/* ======V3R3中使用: HDLC时钟在寄存器SC_PERIPH_CLKEN0 和 C_PERIPH_CLKDIS0 16bit的位置======== */
#define     HDLC_PERIPH_CLK_BITPOS                              (16UL)

/* ======V7R2中使用: HDLC时钟在寄存器CRG_CLKEN4 和 CRG_CLKDIS4 10bit的位置======== */
#define     HDLC_CRG_CLK_BITPOS                                 (10UL)

#if (SC_CTRL_MOD_6930_SFT == SC_CTRL_MOD)
/* ======V7R2中的时钟使能寄存器======== */
#define     HDLC_CRG_CLKEN4_ADDR(base)                          ((base) + (HI_CRG_CLKEN4_OFFSET))

/* ======V7R2中的时钟关闭寄存器======== */
#define     HDLC_CRG_CLKENDIS4_ADDR(base)                       ((base) + (HI_CRG_CLKDIS4_OFFSET))

/* ======V7R2中的时钟状态寄存器======== */
#define     HDLC_CRG_CLKSTA4_ADDR(base)                         ((base) + (HI_CRG_CLKSTAT4_OFFSET))

#endif



/*******************************************************************************
  3 枚举定义
*******************************************************************************/
enum PPP_HDLC_PARA_CHECK_RESULT_ENUM
{
    PPP_HDLC_PARA_CHECK_PASS            = 0,      /* 参数符合要求，将该数据出队 */
    PPP_HDLC_PARA_CHECK_FAIL_DISCARD    = 1,      /* 数据包参数不符合要求，需要丢弃，但是继续处理下一个数据包 */
    PPP_HDLC_PARA_CHECK_FAIL_KEEP       = 2,      /* 数据包参数不符合要求，但需要保留，用于下次处理 */

    PPP_HDLC_PARA_CHECK_BUTT
};
typedef VOS_UINT32   PPP_HDLC_PARA_CHECK_RESULT_ENUM_UINT32;

enum HDLC_MNTN_EVENT_TYPE_ENUM
{
    ID_HDLC_MNTN_FRM_REG_BEFORE_EN     = 101,     /* _H2ASN_MsgChoice HDLC_MNTN_FRM_REG_CONFIG_STRU */
    ID_HDLC_MNTN_FRM_REG_AFTER_EN,                /* _H2ASN_MsgChoice HDLC_MNTN_FRM_REG_CONFIG_STRU */
    ID_HDLC_MNTN_FRM_INPUT_PARA,                  /* _H2ASN_MsgChoice HDLC_MNTN_INPUT_PARA_LINK_STRU */
    ID_HDLC_MNTN_FRM_OUTPUT_PARA,                 /* _H2ASN_MsgChoice HDLC_MNTN_FRM_OUTPUT_PARA_STRU */
    ID_HDLC_MNTN_FRM_INPUT_DATA,                  /* _H2ASN_MsgChoice HDLC_MNTN_NODE_DATA_STRU */
    ID_HDLC_MNTN_FRM_OUTPUT_DATA,                 /* _H2ASN_MsgChoice HDLC_MNTN_NODE_DATA_STRU */
    ID_HDLC_MNTN_DEF_REG_BEFORE_EN,               /* _H2ASN_MsgChoice HDLC_MNTN_DEF_REG_CONFIG_STRU */
    ID_HDLC_MNTN_DEF_REG_AFTER_EN,                /* _H2ASN_MsgChoice HDLC_MNTN_DEF_REG_CONFIG_STRU */
    ID_HDLC_MNTN_DEF_INPUT_PARA,                  /* _H2ASN_MsgChoice HDLC_MNTN_INPUT_PARA_LINK_STRU */
    ID_HDLC_MNTN_DEF_OUTPUT_PARA,                 /* _H2ASN_MsgChoice HDLC_MNTN_DEF_OUTPUT_PARA_STRU */
    ID_HDLC_MNTN_DEF_INPUT_DATA,                  /* _H2ASN_MsgChoice HDLC_MNTN_NODE_DATA_STRU */
    ID_HDLC_MNTN_DEF_OUTPUT_DATA,                 /* _H2ASN_MsgChoice HDLC_MNTN_NODE_DATA_STRU */
    ID_HDLC_MNTN_DEF_UNCOMPLETED_INFO,            /* _H2ASN_MsgChoice HDLC_MNTN_DEF_UNCOMPLETED_INFO_STRU */

    ID_HDLC_MNTN_EVENT_TYPE_BUTT         = 0xFFFF
};
typedef VOS_UINT32 HDLC_MNTN_EVENT_TYPE_ENUM_UINT32;

/*****************************************************************************
  4 消息头和消息类型定义
*****************************************************************************/

/*****************************************************************************
  5 STRUCT定义
*****************************************************************************/
/* 一组数据解出的错误帧数统计 */
typedef struct
{
    VOS_UINT16  usFCSErrCnt;          /* FCS错误 */
    VOS_UINT16  usLenLongCnt;         /* 帧长度过长, 超过1502字节 */
    VOS_UINT16  usLenShortCnt;        /* 帧长度过短, 少于4字节 */
    VOS_UINT16  usErrProtocolCnt;     /* 协议字段不满足xxxxxxx0, xxxxxxx1的形式 */
    VOS_UINT16  usErrCtrlCnt;         /* 控制字段不为0xFF */
    VOS_UINT16  usErrAddrCnt;         /* 地址字段不为0x03 */
    VOS_UINT16  usFlagPosErrCnt;      /* 0x7D后紧接着0x7E */
    VOS_UINT8   aucReserve[2];
} HDLC_DEF_ERR_FRAMES_CNT_STRU;

/*
   参数链表节点结构:
   软件保证解封装输入链表参数起始地址Word对齐；(参见HiHDLCV200逻辑需求规格说明书)，
   从上到下，地址增加，分别为节点内存指针、节点长度、下个节点地址；
   长度LEN有效16bits处于低Half_Word；地址ADDR 32bits
*/
typedef struct _HDLC_PARA_LINK_NODE_STRU
{
    VOS_UINT8                          *pucDataAddr;            /* 该参数节点指向内存地址 */
    VOS_UINT16                          usDataLen;              /* 内存长度，单位Byte */
    VOS_UINT8                           aucReserve[2];
    struct _HDLC_PARA_LINK_NODE_STRU   *pstNextNode;            /* 指向下一个参数节点的指针 */
} HDLC_PARA_LINK_NODE_STRU;

/* 构造参数链表结果信息 */
typedef struct _HDLC_PARA_LINK_BUILD_PARA_STRU
{
    PPP_DATA_TYPE_ENUM_UINT8            ucDataType;             /* 数据类型 */
    VOS_UINT8                           aucReserve1[3];
    VOS_UINT16                          usPppId;                /* PPP ID */
    VOS_UINT16                          usProtocol;             /* 协议类型，封装的时候使用 */
    PPP_ZC_QUEUE_STRU                  *pstDataQ;               /* 数据队列 */
} HDLC_PARA_LINK_BUILD_PARA_STRU;

/* 构造参数链表结果信息 */
/*lint -e506*/
typedef struct _HDLC_PARA_LINK_BUILD_INFO_STRU
{
    VOS_UINT32                          ulDealCnt;              /* 本次构造链表过程从数据队列中总共处理的数据包个数 */
    VOS_UINT32                          ulInputLinkNodeCnt;     /* 输入参数链表节点个数 */
    VOS_UINT32                          ulInputLinkTotalSize;   /* 输入参数链表节点数据包总长度 */
    PPP_ZC_STRU *                       apstInputLinkNode[HDLC_INPUT_PARA_LINK_MAX_SIZE];   /* 输入参数链表节点对应的零拷贝内存 */
    VOS_UINT32                          ulOutputLinkNodeCnt;                                /* 输出参数链表节点个数，只在封装有效 */
    VOS_UINT32                          ulOutputLinkTotalSize;                              /* 输出参数链表节点数据包总长度，只在封装有效 */
    PPP_ZC_STRU *                       apstOutputLinkNode[HDLC_OUTPUT_PARA_LINK_MAX_SIZE]; /* 输出参数链表节点对应的零拷贝内存，只在封装有效 */
} HDLC_PARA_LINK_BUILD_INFO_STRU;
/*lint +e506*/

/*
封装上报空间结点结构:
软件保证封装上报空间起始地址Word对齐；(参见HiHDLCV200逻辑需求规格说明书)，
从上到下，地址增加，分别为输出数据起始地址、数据长度；
长度LEN有效16bits处于低Half_Word；地址ADDR 32bits
*/
typedef struct
{
    VOS_UINT8                          *pucFrmOutOneAddr;       /* 指向封装出的有效帧的在外存储起始地址 */
    VOS_UINT16                          usFrmOutOneLen;         /* 有效帧的长度 */
    VOS_UINT8                           aucReserve[2];
} HDLC_FRM_RPT_NODE_STRU;

/* 保存封装使用的内存 */
typedef struct
{
    HDLC_PARA_LINK_NODE_STRU            astInputParaLinkNodeBuf[TTF_HDLC_FRM_INPUT_PARA_LINK_MAX_NUM];  /* 封装输入参数链表使用的内存 */
    HDLC_FRM_RPT_NODE_STRU              astRptNodeBuf[TTF_HDLC_FRM_RPT_MAX_NUM];                        /* 封装信息上报空间使用的内存 */
    HDLC_PARA_LINK_NODE_STRU            astOutputParaLinkNodeBuf[TTF_HDLC_FRM_OUTPUT_PARA_LINK_MAX_NUM];/* 封装输出参数链表使用的内存 */
} HDLC_FRM_BUFF_INFO_STRU;


/*
解封装上报空间结点结构:
软件保证解封装上报空间起始地址Word对齐；(参见HiHDLCV200逻辑需求规格说明书)，
从上到下，地址增加，分别为输出数据协议类型、长度和存储地址；
长度LEN有效16bits处于低Half_Word；协议PRO有效16bits处于高Half-Word；地址ADDR 32bits
*/
typedef struct
{
    VOS_UINT16                          usDefOutOneLen;         /* 有效帧的长度 */
    VOS_UINT16                          usDefOutOnePro;         /* 有效帧的协议 */
    VOS_UINT8                          *pucDefOutOneAddr;       /* 指向解封装出的有效帧在外存储的起始地址 */
} HDLC_DEF_RPT_NODE_STRU;


/* 解封装非完整帧信息存储结构 */
typedef struct
{
    VOS_UINT8                           ucExistFlag;            /* 非完整帧是否存在标识 */
    VOS_UINT8                           aucReserve1[3];
    VOS_UINT16                          usDefOutOnePro;         /* 非完整帧的协议 */
    VOS_UINT16                          usDefOutOneLen;         /* 非完整帧的长度 */
    VOS_UINT8                          *pucDefOutOneAddr;       /* 指向解封装出的非完整帧在外存储的起始地址 */
    VOS_UINT32                          ulDefStAgo;             /* 用于保存def_uncomplet_st_now寄存器值 */
    VOS_UINT32                          ulDefInfoFrlCntAgo;     /* 用于保存def_info_frl_cnt_ago寄存器值 */
} HDLC_DEF_UNCOMPLETED_INFO_STRU;

/* 保存解封装使用的内存 */
typedef struct
{
    HDLC_PARA_LINK_NODE_STRU            astInputParaLinkNodeBuf[TTF_HDLC_DEF_INPUT_PARA_LINK_MAX_NUM];/* 解封装输入参数链表使用的内存 */
    HDLC_DEF_RPT_NODE_STRU              astRptNodeBuf[TTF_HDLC_DEF_RPT_MAX_NUM];                      /* 解封装信息上报空间使用的内存 */
    VOS_UINT8                           aucOutputDataBuf[TTF_HDLC_DEF_OUTPUT_DATA_BUF_LEN];           /* 解封装目的空间使用的内存 */
} HDLC_DEF_BUFF_INFO_STRU;

/* 输入参数链表可维可测结构 */
typedef struct
{
    VOS_MSG_HEADER                                              /* 消息头 */
    HDLC_MNTN_EVENT_TYPE_ENUM_UINT32    ulMsgname;
}HDLC_MNTN_TRACE_HEAD_STRU;

/* 封装相关寄存器可维可测结构 */
typedef struct
{
    HDLC_MNTN_TRACE_HEAD_STRU           stHead;                     /* _H2ASN_Skip */
    VOS_UINT32                          ulStateSwRst;
    VOS_UINT32                          ulPriorTimeoutCtrl;
    VOS_UINT32                          ulRdErrCurrAddr;
    VOS_UINT32                          ulWrErrCurrAddr;
    VOS_UINT32                          ulHdlcFrmEn;
    VOS_UINT32                          ulHdlcFrmRawInt;
    VOS_UINT32                          ulHdlcFrmIntStatus;
    VOS_UINT32                          ulHdlcFrmIntClr;
    VOS_UINT32                          ulHdlcFrmCfg;
    VOS_UINT32                          ulHdlcFrmAccm;
    VOS_UINT32                          ulHdlcFrmStatus;
    VOS_UINT32                          ulFrmInLliAddr;
    VOS_UINT32                          ulFrmInSublliAddr;
    VOS_UINT32                          ulFrmInPktLen;
    VOS_UINT32                          ulFrmInBlkAddr;
    VOS_UINT32                          ulFrmInBlkLen;
    VOS_UINT32                          ulFrmOutLliAddr;
    VOS_UINT32                          ulFrmOutSpaceAddr;
    VOS_UINT32                          ulFrmOutSpaceDep;
    VOS_UINT32                          ulFrmRptAddr;
    VOS_UINT32                          ulFrmRptDep;
} HDLC_MNTN_FRM_REG_CONFIG_STRU;

/* 解封装相关寄存器可维可测结构 */
typedef struct
{
    HDLC_MNTN_TRACE_HEAD_STRU           stHead;                     /* _H2ASN_Skip */
    VOS_UINT32                          ulStateSwRst;
    VOS_UINT32                          ulPriorTimeoutCtrl;
    VOS_UINT32                          ulRdErrCurrAddr;
    VOS_UINT32                          ulWrErrCurrAddr;
    VOS_UINT32                          ulHdlcDefEn;
    VOS_UINT32                          ulHdlcDefRawInt;
    VOS_UINT32                          ulHdlcDefIntStatus;
    VOS_UINT32                          ulHdlcDefIntClr;
    VOS_UINT32                          ulHdlcDefCfg;
    VOS_UINT32                          ulDefUncompletedLen;
    VOS_UINT32                          ulDefUncompletedPro;
    VOS_UINT32                          ulDefUncompletedAddr;
    VOS_UINT32                          ulDefUncompleteStAgo;
    VOS_UINT32                          ulHdlcDefGoOn;
    VOS_UINT32                          ulHdlcDefStatus;
    VOS_UINT32                          ulDefUncompletStNow;
    VOS_UINT32                          ulDefInLliAddr;
    VOS_UINT32                          ulDefInPktAddr;
    VOS_UINT32                          ulDefInPktLen;
    VOS_UINT32                          ulDefInPktLenMax;
    VOS_UINT32                          ulDefOutSpcAddr;
    VOS_UINT32                          ulDefOutSpaceDep;
    VOS_UINT32                          ulDefRptAddr;
    VOS_UINT32                          ulDefRptDep;
    VOS_UINT32                          ulHdlcDefErrInfor0;
    VOS_UINT32                          ulHdlcDefErrInfor1;
    VOS_UINT32                          ulHdlcDefErrInfor2;
    VOS_UINT32                          ulHdlcDefErrInfor3;
    VOS_UINT32                          ulDefInfoFr1CntAgo;
    VOS_UINT32                          ulDefInfoFr1CntNow;
} HDLC_MNTN_DEF_REG_CONFIG_STRU;

/* 输出和输出数据内容勾包*/
typedef struct
{
    HDLC_MNTN_TRACE_HEAD_STRU           stHead;                         /* _H2ASN_Skip */
    VOS_UINT16                          usNodeIndex;
    VOS_UINT16                          usLen;
    /* VOS_UINT8[usLen]数据内容放在这里，申请的时候由头加上数据内容长度 */
}HDLC_MNTN_NODE_DATA_STRU;

/* 输入参数链表可维可测结构 */
/*lint -e506*/
typedef struct
{
    HDLC_MNTN_TRACE_HEAD_STRU           stHead;                         /* _H2ASN_Skip */
    VOS_UINT32                          ulInputLinkNodeCnt;     /* 输入参数链表节点个数 */
    VOS_UINT32                          ulInputLinkTotalSize;   /* 输入参数链表节点数据包总长度 */
    HDLC_PARA_LINK_NODE_STRU            astInputParaLinkNodeBuf[HDLC_INPUT_PARA_LINK_MAX_SIZE];
}HDLC_MNTN_INPUT_PARA_LINK_STRU;
/*lint +e506*/

/* 封装输出结果可维可测结构 */
typedef struct
{
    HDLC_MNTN_TRACE_HEAD_STRU           stHead;                         /* _H2ASN_Skip */
    VOS_UINT8                           ucFrmValidNum;
    VOS_UINT8                           ucReserve1[1];
    VOS_UINT16                          usOutputNodeUsedCnt;
    VOS_UINT32                          ulOutputLinkNodeCnt;    /* 输出参数链表节点个数，只在封装有效 */
    VOS_UINT32                          ulOutputLinkTotalSize;  /* 输出参数链表节点数据包总长度，只在封装有效 */
    HDLC_PARA_LINK_NODE_STRU            astOutputParaLinkNodeBuf[TTF_HDLC_FRM_OUTPUT_PARA_LINK_MAX_NUM];/* 封装输出参数链表使用的内存 */
    HDLC_FRM_RPT_NODE_STRU              astRptNodeBuf[TTF_HDLC_FRM_RPT_MAX_NUM];                        /* 封装信息上报空间使用的内存 */
}HDLC_MNTN_FRM_OUTPUT_PARA_STRU;

/* 解封装非完整帧可维可测结构 */
typedef struct
{
    HDLC_MNTN_TRACE_HEAD_STRU           stHead;                         /* _H2ASN_Skip */
    HDLC_DEF_UNCOMPLETED_INFO_STRU      stUncompletedInfo;
}HDLC_MNTN_DEF_UNCOMPLETED_INFO_STRU;

/* 解封装输出结果可维可测结构 */
typedef struct
{
    HDLC_MNTN_TRACE_HEAD_STRU           stHead;                         /* _H2ASN_Skip */
    VOS_UINT16                          usDefValidNum;
    VOS_UINT16                          usTraceNum;
    /* HDLC_DEF_RPT_NODE_STRU[usDefValidNum]此处为封装信息上报空间使用的内存，
       申请内存时由结构长度加上报空间需要的内存大小 */
}HDLC_MNTN_DEF_OUTPUT_PARA_STRU;

/* HDLC配置相关信息结构 */
typedef struct
{
    VOS_UINT32                          ulHDLCIPBaseAddr;      /* 从底软获取的HDLC基地址 */
    VOS_UINT32                          ulHdlcDefMasterSem;    /* 解封装信号量 */
    VOS_UINT32                          ulHdlcFrmMasterSem;    /* 封装信号量 */
    VOS_INT32                           slHdlcISRDef;          /* 解封装中断号 */
    VOS_INT32                           slHdlcISRFrm;          /* 封装中断号 */
    VOS_UINT32                          ulHdlcDefIntLimit;     /* 解封装中断水线 */
    VOS_UINT32                          ulHdlcFrmIntLimit;     /* 封装中断水线 */
    HTIMER                              stHdlcFrmTimerHandle;  /* 申请封装目的空间失败定时器句柄 */
    VOS_UINT32                          ulHdlcMntnTraceCfg;    /* 可维可测等级配置 */
}HDLC_CONFIG_INFO_STRU;

/* 统计信息 */
typedef struct
{
    VOS_UINT32                  ulDefIpDataProcCnt;             /* 解封装IP数据包处理个数 */
    VOS_UINT32                  ulDefPppDataProcCnt;            /* 解封装简单PPP帧处理个数 */
    VOS_UINT32                  ulDefUncompleteCnt;             /* 解封装有非完整帧输出次数 */
    VOS_UINT32                  ulDefWaitIntCnt;                /* 解封装等待中断次数 */
    VOS_UINT32                  ulDefWaitQueryCnt;              /* 解封装等待轮询次数 */
    VOS_UINT32                  ulDefLcpPauseCnt;               /* 解封装LCP暂停次数 */
    VOS_UINT32                  ulDefFullPauseCnt;              /* 解封装输出空间或上报空间满暂停次数 */
    VOS_UINT32                  ulDefInputDiscardCnt;           /* 解封装丢弃数据包个数 */

    VOS_UINT32                  ulFrmIpDataProcCnt;             /* 封装IP数据包处理个数 */
    VOS_UINT32                  ulFrmPppDataProcCnt;            /* 封装简单PPP帧处理个数 */
    VOS_UINT32                  ulFrmWaitIntCnt;                /* 封装等待中断次数 */
    VOS_UINT32                  ulFrmWaitQueryCnt;              /* 封装等待轮询次数 */
    VOS_UINT32                  ulFrmAllocOutputMemFailCnt;     /* 封装申请目的内存失败次数 */
    VOS_UINT32                  ulFrmAllocFirstMemFailCnt;      /* 封装申请第一个节点目的内存失败次数 */
    VOS_UINT32                  ulFrmOutputLinkFullCnt;         /* 封装输出链表满次数 */
    VOS_UINT32                  ulFrmInputDiscardCnt;           /* 封装丢弃数据包个数 */

    VOS_UINT32                  ulDefMaxInputCntOnce;           /* 解封装一次最大输入数据个数 */
    VOS_UINT32                  ulDefMaxInputSizeOnce;          /* 解封装一次最大输入数据总长度 */
    VOS_UINT32                  ulDefMaxValidCntOnce;           /* 解封装一次最大输出有效帧个数 */
    VOS_UINT32                  ulDefMaxQueryCnt;               /* 解封装轮询最大次数 */

    VOS_UINT32                  ulFrmMaxInputCntOnce;           /* 封装一次最大输入数据个数 */
    VOS_UINT32                  ulFrmMaxInputSizeOnce;          /* 封装一次最大输入数据总长度 */
    VOS_UINT32                  ulFrmMaxOutputCntOnce;          /* 封装一次最大输出使用节点数个数 */
    VOS_UINT32                  ulFrmMaxOutputSizeOnce;         /* 封装一次最大输出使用节点总长度 */
    VOS_UINT32                  ulFrmMaxQueryCnt;               /* 封装轮询最大次数 */

    VOS_UINT32                  ulMaxCntOnce;                   /* PPP一次最多处理的结点个数 */
    VOS_UINT32                  ulHdlcHardProcCnt;              /* PPP一次最多处理的结点个数 */

    VOS_UINT32                  ulDefIsrCnt;                    /* 解封装中断服务程序调用次数 */
    VOS_UINT32                  ulFrmIsrCnt;                    /* 封装中断服务程序调用次数 */
    VOS_UINT32                  ulContinueCnt;                  /* 队列中的数据需要分多次处理的次数 */
    VOS_UINT16                  usDefExpInfo;                   /* 解封装异常信息 */
    VOS_UINT16                  usFrmExpInfo;                   /* 封装异常信息 */
    VOS_UINT32                  ulForbidHdlcBugNoCpy;           /* 规避HDLC BUG,不拷贝数据 */
    VOS_UINT32                  ulForbidHdlcBugCpy;             /* 规避HDLC BUG,需要拷贝数据 */
} PPP_HDLC_HARD_DATA_PROC_STAT_ST;

/* HDLC关键寄存器可维可测信息保存结构 */
typedef struct
{
    VOS_UINT32                          ulHdlcFrmRawInt;        /* 封装原始中断寄存器值 */
    VOS_UINT32                          ulHdlcFrmStatus;        /* 封装状态寄存器值 */
    VOS_UINT32                          ulHdlcDefRawInt;        /* 解封装原始中断寄存器值 */
    VOS_UINT32                          ulHdlcDefStatus;        /* 解封装状态寄存器值 */
}HDLC_REG_SAVE_INFO_STRU;

/*****************************************************************************
  6 全局变量声明
*****************************************************************************/
extern HDLC_CONFIG_INFO_STRU                          g_stHdlcConfigInfo;

/*****************************************************************************
  8 UNION定义
*****************************************************************************/


/*****************************************************************************
  9 OTHERS定义
*****************************************************************************/


/*****************************************************************************
  10 函数声明
*****************************************************************************/
extern VOS_UINT32 PPP_HDLC_HARD_Init(VOS_VOID);

extern VOS_VOID   PPP_HDLC_HARD_SetUp(PPP_ID usPppId);

extern VOS_VOID   PPP_HDLC_HARD_Disable(VOS_VOID);

extern PPP_HDLC_RESULT_TYPE_ENUM_UINT32 PPP_HDLC_HARD_ProcData
(
    PPP_ID usPppId,
    struct link *pstLink,
    PPP_ZC_QUEUE_STRU *pstDataQ
);

extern VOS_VOID PPP_HDLC_HARD_ProcProtocolPacket
(
    struct link     *pstLink,
    struct ppp_mbuf *pstMbuf,
    VOS_INT32       ulPri,
    VOS_UINT16      ulProtocol
);

extern VOS_VOID PPP_HDLC_HARD_ProcAsFrmPacket
(
    VOS_UINT16       usPppId,
    VOS_UINT16       usProtocol,
    PPP_ZC_STRU     *pstMem
);

extern VOS_VOID PPP_HDLC_HARD_PeriphClkOpen(VOS_VOID);
extern VOS_VOID PPP_HDLC_HARD_PeriphClkClose(VOS_VOID);

extern VOS_UINT32 PPP_PHY_TO_VIRT(unsigned int ulPAddr);

extern VOS_UINT32 PPP_VIRT_TO_PHY(unsigned int ulVAddr);

#else
/*****************************************************************************
  2 宏定义
*****************************************************************************/
/* definitions of bit basic operations */
#define GET_HIGH_WORD_FROM_DWORD(l)           ((VOS_UINT16)((((VOS_UINT32)(l)) >> 16) & 0xFFFF))
#define GET_LOW_WORD_FROM_DWORD(l)           ((VOS_UINT16)(VOS_UINT32)(l))
#define GET_HIGH_BYTE_FROM_WORD(w)           ((VOS_UINT8)(((VOS_UINT16)(w) >> 8) & 0xFF))
#define GET_LOW_BYTE_FROM_WORD(w)           ((VOS_UINT8)(w))
#define HDLC_MAKE_DWORD(hi,low)    ((VOS_UINT32)(((VOS_UINT16)(low))|(((VOS_UINT32)((VOS_UINT16)(hi)))<<16)))
#define HDLC_MAKE_WORD(hi,low)    ((VOS_UINT16)(((VOS_UINT8)(low))|(((VOS_UINT16)((VOS_UINT8)(hi)))<<8)))

#define GET_BITS_FROM_DWORD(DWord, BitMask) ((DWord) & (BitMask))
#define GET_BITS_FROM_WORD(Word, BitMask) ((Word) & (BitMask))
#define GET_BITS_FROM_BYTE(Byte, BitMask)  ((Byte) & (BitMask))
#define SET_BITS_VALUE_TO_BYTE(ucValue, ucStartBitPosition)     ((VOS_UINT8)((ucValue) << (ucStartBitPosition)))

#define SET_BIT_TO_BYTE(ucByte, ucBitPosition)          ((ucByte) |= (0x01 << (ucBitPosition)))
#define CLEAR_BIT_TO_BYTE(ucByte, ucBitPosition)        ((ucByte) &= ~(0x01 << (ucBitPosition)))

#define SET_BIT_TO_WORD(usWord, ucBitPosition)          ((usWord) |= (0x0001 << (ucBitPosition)))
#define CLEAR_BIT_TO_WORD(usWord, ucBitPosition)        ((usWord) &= ~(0x0001 << (ucBitPosition)))

#define SET_BIT_TO_DWORD(ulDWord, ucBitPosition)        ((ulDWord) |= (0x00000001 << (ucBitPosition)))
#define CLEAR_BIT_TO_DWORD(ulDWord, ucBitPosition)      ((ulDWord) &= ~(0x00000001 << (ucBitPosition)))


/* added HDLC register value definition here */
#define     HDLC_FRAMER_ENABLE                          (0x01)
#define     HDLC_FRAMER_DISABLE                         (0x00)

/* definition of HDLC module: FRAMER, DEFRAMER */
#define     HDLC_FRAMER_MODULE                          (0UL)
#define     HDLC_DEFRAMER_MODULE                        (1UL)

/* definition of PPP Link type */
#define     HDLC_IP_MODE                                (0UL)
#define     HDLC_PPP_MODE                               (1UL)

/* definition of wait times of HDLC */
#define     HDLC_FRAMER_MAX_WAIT_RESULT_NUM             (0xFFFF)
#define     HDLC_DEFRAMER_MAX_WAIT_RESULT_NUM           (0xFFFF)

/* definition of data packet or frame type */
#define     HDLC_IP_FRAME_CHOSEN                        (0UL)
#define     HDLC_NOT_IP_FRAME_CHOSEN                    (1UL)

/* 约定软硬件, 封装一组最多提交1502字节给Framer */
#define     HDLC_FRAMER_IN_PER_MAX_CNT                  (1502L)

#define     HDLC_FRAMER_OUT_PER_MAX_CNT                 (3013UL)

/* 约定软硬件, 解封装一次最多提交3013字节给Deframer */
#define     HDLC_DEFRAMER_IN_PER_MAX_CNT                (3013UL)

#define     HDLC_DEFRAMER_OUT_LIST_MAX_CNT              (603UL)

#define     HDLC_DEFRAMER_OUT_ALL_FRAMES_MAX_USED_BYTES (6414UL)

/* 封装上报每帧最长1502字节, IPv4最长1500字节, PPP模式带上协议字段2字节, 共1502字节 */
#define     HDLC_FRAMER_IN_PER_FRAME_MAX_USED_BYTES     (1502UL)

/* 解封装数据一次最长4096字节, 这是由底软设计规格所致 */
#define     HDLC_DEFRAMER_IN_ALL_FRAMES_MAX_USED_BYTES  (4096UL)

/* 解封装上报每帧最长1502字节, IPv4最长1500字节, PPP模式带上协议字段2字节, 共1502字节 */
#define     HDLC_DEFRAMER_OUT_PER_FRAME_MAX_USED_BYTES  (1502UL)


#define     HDLC_DEFRAMER_PER_FRAME_INFO_DWORD_USE      (2UL)   /* 解封装上报列表中每帧信息占用2个DWORD */
#define     HDLC_DEFRAMER_PER_FRAME_ADDR_DWORD_OFFSET   (1UL)   /* 解封装上报列表中每帧地址相对偏移: 1个DWORD */

#define     HDLC_DEFRAMER_MAX_TYPE_CNT                  (7UL)


/* definition of bit positions and masks in a register */
/* ========================= hdlc_int_en (0x04) begin ======================= */
/* HDLC模块中断使能寄存器地址: 相对偏移地址量0x04 */

/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器frm_len_err0_en在bit0;
        寄存器frm_len_err1_en在bit1;
        寄存器frm_cfg_err_en在bit2;
        寄存器def_len_err0_en在bit8;
        寄存器def_len_err1_en在bit9;
        寄存器def_cfg_err_en在bit10;
*/
#define     HDLC_INTERRUPT_FRAMER_DATA_LEN_SHORT_ERR_EN_BITPOS      (0UL)
#define     HDLC_INTERRUPT_FRAMER_DATA_LEN_LONG_ERR_EN_BITPOS       (1UL)
#define     HDLC_INTERRUPT_FRAMER_PARA_ERR_EN_BITPOS                (2UL)
#define     HDLC_INTERRUPT_DEFRAMER_DATA_LEN_SHORT_ERR_EN_BITPOS    (8UL)
#define     HDLC_INTERRUPT_DEFRAMER_DATA_LEN_LONG_ERR_EN_BITPOS     (9UL)
#define     HDLC_INTERRUPT_DEFRAMER_PARA_ERR_EN_BITPOS              (10UL)
/* ========================== hdlc_int_en (0x04) end ======================== */


/* ========================= hdlc_int_raw_data (0x08) begin ======================= */
/* HDLC模块中断使能寄存器地址: 相对偏移地址量0x08 */
/* ========================== hdlc_int_status (0x08) end ======================== */


/* ========================= hdlc_int_status (0x0C) begin ======================= */
/* HDLC模块中断使能寄存器地址: 相对偏移地址量0x0C */
/* ========================== hdlc_int_status (0x0C) end ======================== */


/* ====================== hdlc_int_clr (0x10) begin ===================== */
/* HDLC模块中断清除寄存器地址: 相对偏移地址量0x10 */

/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器frm_len_err0_clr在bit0;
        寄存器frm_len_err1_clr在bit1;
        寄存器frm_cfg_err_clr在bit2;
        寄存器def_len_err0_clr在bit8;
        寄存器def_len_err1_clr在bit9;
        寄存器def_cfg_err_clr在bit10;
*/
#define     HDLC_INTERRUPT_FRAMER_DATA_LEN_SHORT_ERR_CLEAR_BITPOS      (0UL)
#define     HDLC_INTERRUPT_FRAMER_DATA_LEN_LONG_ERR_CLEAR_BITPOS       (1UL)
#define     HDLC_INTERRUPT_FRAMER_PARA_ERR_CLEAR_BITPOS                (2UL)
#define     HDLC_INTERRUPT_DEFRAMER_DATA_LEN_SHORT_ERR_CLEAR_BITPOS    (8UL)
#define     HDLC_INTERRUPT_DEFRAMER_DATA_LEN_LONG_ERR_CLEAR_BITPOS     (9UL)
#define     HDLC_INTERRUPT_DEFRAMER_PARA_ERR_CLEAR_BITPOS              (10UL)

/* ======================= hdlc_int_frm_clr (0x10) end ====================== */


/* ======================== hdlc_frm_cfg(0x20) begin ======================== */
/* 封装模块配置寄存器地址: 相对偏移地址量0x20 */

/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器frm_en在bit0;
        寄存器frm_acfc在bit1;
*/
#define     HDLC_FRAMER_CFG_EN_BITPOS                  (0UL)
#define     HDLC_FRAMER_CFG_ACFC_BITPOS                (1UL)

/*
   寄存器frm_pfc在hdlc_frm_cfg的bit2, bit3,
   相对bit0偏移2bits
*/
#define     HDLC_FRAMER_CFG_PFC_MOVEBITS_LEN            (2UL)

/*
   寄存器frm_pfc(2bits)各值含义:
        00b: 硬件模块添加P域, P域无压缩;
        01b: 硬件模块添加P域, P域压缩;
        11b: 硬件模块不添加P域;
*/
#define     HDLC_PROTOCOL_ADD_WITHOUT_COMPRESS   (0x00)
#define     HDLC_PROTOCOL_ADD_WITH_COMPRESS      (0x01)
#define     HDLC_PROTOCOL_NO_ADD                 (0x03)
/* ========================= hdlc_frm_cfg(0x20) end ========================= */


/* ======================== hdlc_frm_accm(0x24) begin ======================= */
/* 封装模块转义使能寄存器地址: 相对偏移地址量0x24 */
/* ========================= hdlc_frm_accm(0x24) end ======================== */


/* ======================= hdlc_frm_ctrl (0x28) begin ======================= */
/* 封装模块控制寄存器地址: 相对偏移地址量0x28 */

/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器frm_block_new在bit0;
*/
#define     HDLC_FRAMER_CTRL_BLK_NEW_BITPOS             (0UL)

/*
   寄存器frm_block_index在hdlc_frm_ctrl的bit12-bit14,
   相对bit8偏移4bits
*/
#define     HDLC_FRAMER_CTRL_BLK_IDX_MOVEBITS_LEN            (4UL)

/*
   寄存器frm_block_num在hdlc_frm_ctrl的bit8-bit10,
   相对bit8偏移0bits
*/
#define     HDLC_FRAMER_CTRL_BLK_CNT_MOVEBITS_LEN            (0UL)
/* ======================== hdlc_frm_ctrl (0x28) end ======================== */


/* ====================== hdlc_frm_status (0x2C) begin ====================== */
/* 封装模块状态寄存器地址: 相对偏移地址量0x2C */

/* 寄存器frm_frm_length(10bits)的MASK表 */
#define     HDLC_FRAMER_BLOCK_LENGTH_MASK                 (0x000003FF)

/* 寄存器frm_block_done(1bit)的MASK表 */
#define     HDLC_FRAMER_BLOCK_DONE_MASK                 (0x00000001)

/*
   寄存器frm_block_done(1bit)各值含义:
        0b: 未完成一组数据处理;
        1b: 完成一组数据处理;
*/
#define     HDLC_FRAMER_BLOCK_NOT_DONE                  (0x00)
#define     HDLC_FRAMER_BLOCK_DONE                      (0x01)
/* ======================= hdlc_frm_status (0x2C) end ======================= */


/* ======================= hdlc_def_cfg (0x40) begin ======================== */
/* hdlc_def_cfg (0x40) */

/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器def_en在bit0;
        寄存器def_acfc在bit1;
*/
#define     HDLC_DEFRAMER_CFG_EN_BITPOS             (0UL)
#define     HDLC_DEFRAMER_CFG_ACFC_BITPOS             (1UL)

/*
   寄存器def_pfc在hdlc_def_cfg的bit2, bit3,
   相对bit0偏移2bits
*/
#define     HDLC_DEFRAMER_CFG_PFC_MOVEBITS_NUM            (2UL)

/*
   寄存器def_pfc(2bits)各值含义:
        00b: P域无压缩, 需剥离;
        01b: P域压缩, 需剥离;
        11b: P域不剥离;
*/
#define     HDLC_PROTOCOL_REMOVE_WITHOUT_COMPRESS      (0x00)
#define     HDLC_PROTOCOL_REMOVE_WITH_COMPRESS         (0x01)
#define     HDLC_PROTOCOL_NO_REMOVE                    (0x03)
/* ======================== hdlc_def_cfg (0x40) end ========================= */


/* ====================== hdlc_def_ctrl (0x44) begin ======================== */

/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器def_block_new在bit0;
*/
#define     HDLC_DEFRAMER_CTRL_BLK_NEW_BITPOS             (0UL)
/* ======================= hdlc_def_ctrl (0x44) end ========================= */


/* ====================== hdlc_def_go_on(0x48) begin ======================== */

/*
   定义寄存器在32bit Reg中的bit位置:
        寄存器def_go_on在bit0;
*/
#define     HDLC_DEFRAMER_GO_ON_BITPOS             (0UL)
/* ======================= hdlc_def_go_on(0x48) end ========================= */


/* ======================= hdlc_def_status (0x4C) begin ===================== */
/* 解封装状态寄存器地址: 相对偏移地址量0x4C */

/* 寄存器def_block_pro_stat(2bits)的MASK表 */
#define     HDLC_DEFRAMER_BLOCK_STATUS_MASK         (0x00000003)

/*
   寄存器def_block_pro_stat(2bits)各值含义:
        00b: 未完成一组数据处理;
        01b: 未完成一组数据处理, 已解出LCP帧, 硬件处于暂停状态;
        10b: 完成一组数据处理, 但无帧上报;
        11b: 完成一组数据处理, 且有帧上报;
*/
#define     HDLC_DEFRAMER_BLOCK_STATUS_DOING                    (0x00)
#define     HDLC_DEFRAMER_BLOCK_STATUS_PAUSE                    (0x01)
#define     HDLC_DEFRAMER_BLOCK_STATUS_DONE_WITHOUT_FRAMES      (0x02)
#define     HDLC_DEFRAMER_BLOCK_STATUS_DONE_WITH_FRAMES         (0x03)

/* 寄存器def_valid_num(6bits)的MASK表 */
#define     HDLC_DEFRAMER_VALID_CNT_MASK         (0x003F)

/* 寄存器def_err_type(7bits)的MASK表 */
#define     HDLC_DEFRAMER_ERROR_TYPE_MASK         (0x7F)
/* ======================= hdlc_def_status (0x4C) end ======================= */


/* =================== hdlc_def_err_infor_0 (0x50) begin ==================== */
/* 解封装错误帧统计寄存器第一组: 相对偏移地址量0x50 */
/* ==================== hdlc_def_err_infor_0 (0x50) end ===================== */


/* =================== hdlc_def_err_infor_1 (0x54) begin ==================== */
/* 解封装错误帧统计寄存器第一组: 相对偏移地址量0x54 */

/* ==================== hdlc_def_err_infor_1 (0x54) end ===================== */

/* 申请封装目的空间失败定时器参数 */
#define     HDLC_FRM_OUTPUT_SPACE_ALLOC_FAIL                    (10)

/*******************************************************************************
  3 枚举定义
*******************************************************************************/
enum HDLC_RESET_REASON_ENUM
{
    HDLC_FRAMER_OUT_PER_LONG_ERR  = 0,    /* Framer out per group data too long */
    HDLC_FRAMER_OUT_ALL_LONG_ERR     ,    /* Framer out all group data too long */
    HDLC_FRAMER_WORK_TIME_LONG_ERR   ,    /* Framer work too long */
    HDLC_DEFRAMER_OUT_LIST_LONG_ERR  ,    /* Deframer out list group too more */
    HDLC_DEFRAMER_OUT_PER_LONG_ERR   ,    /* Deframer out per group data too long */
    HDLC_DEFRAMER_OUT_OFFSET_LONG_ERR,    /* Deframer out per group data offset too long */
    HDLC_DEFRAMER_OUT_ADDRESS_ERR    ,    /* Deframer out per group data address can not pack four */
    HDLC_DEFRAMER_WORK_TIME_LONG_ERR ,    /* Deframer work too long */
    HDLC_DEFRAMER_ERR_BUTT
};
typedef VOS_UINT8 HDLC_RESET_REASON_ENUM_UINT8;

enum HDLC_DATA_STORE_ENUM
{
    HDLC_DATA_STORE_M_BUF         = 0,
    HDLC_DATA_STORE_TTF_MEM          ,
    HDLC_DATA_STORE_BUTT
} ;
typedef VOS_UINT8 HDLC_DATA_STORE_ENUM_UINT8;


/*****************************************************************************
  4 全局变量声明
*****************************************************************************/
typedef struct _PPP_HDLC_PARA_LINK_NODE_STRU
{
    VOS_UINT8                              *pucData;      /*该参数节点指向内存地址*/
    VOS_UINT32                              ulLength;     /*内存长度，单位Byte*/
    struct _PPP_HDLC_PARA_LINK_NODE_STRU   *pstNextNode;   /*指向下一个参数节点的指针*/
}PPP_HDLC_PARA_LINK_NODE_STRU;

/*****************************************************************************
  5 消息头和消息类型定义
*****************************************************************************/

/*****************************************************************************
  7 STRUCT定义
*****************************************************************************/
/* 待封装的数据情况, 作为HDLC Framer的入参 */
typedef struct
{
    VOS_UINT32        ulDataLen;            /* 待封装的数据长度, 单位: 字节 */

    /* 待封装的数据的来源 */
    PPP_ZC_STRU      *pstMem;
} HDLC_FRAMER_IN_DATA_CHOICE_STRU;

/* 封装后的数据情况, 作为HDLC Framer的出参 */
typedef struct
{
    VOS_UINT8       *pucData;           /* 指向封装后的数据的首地址 */
    VOS_UINT16       usFrameByteCnt;    /* 指向封装后的数据长度, 单位: 字节 */
    VOS_UINT8        aucReserve[2];
} HDLC_FRAMER_OUT_DATA_STRU;

/* HDLC Framer的参数 */
typedef struct
{
    VOS_UINT8         ucMode;           /* IP模式, 还是PPP模式 */
    VOS_UINT8         aucReserve[3];

    HDLC_FRAMER_IN_DATA_CHOICE_STRU    stInData;    /* 封装入参 */
    HDLC_FRAMER_OUT_DATA_STRU    stOutData;     /* 封装出参 */

    VOS_UINT16   usProtocol;    /* 待封装的协议 */

    PS_BOOL_ENUM_UINT8    enPComp;      /* 是否压缩协议字段, 是 - PS_TRUE */
    PS_BOOL_ENUM_UINT8    enACComp;     /* 是否压缩地址和控制字段, 是 - PS_TRUE */
    VOS_UINT32   ulACCM;
} HDLC_FRAMER_PARA_STRU;

/* 封装时用到的PPP链接参数 */
typedef struct
{
    struct link *l;    /* PPP链接参数 */
} HDLC_FRAMER_PPP_LINK_PARA_STRU;

/* 待解封装的数据, 作为HDLC Deframer的入参 */
typedef struct
{
    VOS_UINT8   *pucData;   /* 指向待解封装的数据 */
    VOS_UINT32   ulLen;     /* 待解封装的数据长度, 单位: 字节 */
} HDLC_DEFRAMER_IN_DATA_STRU;

/* HDLC Deframer的参数 */
typedef struct
{
    VOS_UINT8             ucMode;       /* IP模式, 还是PPP模式 */
    PS_BOOL_ENUM_UINT8    enPComp;      /* 是否压缩协议字段, 是 - PS_TRUE */
    PS_BOOL_ENUM_UINT8    enACComp;     /* 是否压缩地址和控制字段, 是 - PS_TRUE */
    VOS_UINT8             aucReserve[1];

    HDLC_DEFRAMER_IN_DATA_STRU     stDeframerInData;    /* 解封装入参 */
} HDLC_DEFRAMER_PARA_STRU;

/* 解封装时用到的PPP链接参数 */
typedef struct
{
    struct link *l;    /* PPP链接参数 */
} HDLC_DEFRAMER_PPP_LINK_PARA_STRU;

/* 一组数据解出的错误帧数统计 */
typedef struct
{
    VOS_UINT16  usFCSErrCnt;          /* FCS错误 */
    VOS_UINT16  usLenLongCnt;         /* 帧长度过长, 超过1502字节 */
    VOS_UINT16  usLenShortCnt;        /* 帧长度过短, 少于4字节 */
    VOS_UINT16  usErrProtocolCnt;     /* 协议字段不满足xxxxxxx0, xxxxxxx1的形式 */
    VOS_UINT16  usErrCtrlCnt;         /* 控制字段不为0xFF */
    VOS_UINT16  usErrAddrCnt;         /* 地址字段不为0x03 */
    VOS_UINT16  usFlagPosErrCnt;      /* 0x7D后紧接着0x7E */
    VOS_UINT8   aucReserve[2];
} HDLC_DEFRAMER_ERR_FRAMES_CNT_STRU;


typedef struct
{
    PS_BOOL_ENUM_UINT8 enFramerErrorEnable;         /* 封装模块异常中断上报使能, 使能 - PS_TRUE */
    PS_BOOL_ENUM_UINT8 enFramerDataLessEnable;      /* 封装模块数据不足异常中断使能, 使能 - PS_TRUE */
    PS_BOOL_ENUM_UINT8 enFramerDataMoreEnable;      /* 封装模块数据过多异常中断使能, 使能 - PS_TRUE */
    PS_BOOL_ENUM_UINT8 enDeframerErrorEnable;       /* 解封装模块异常中断上报使能, 使能 - PS_TRUE */
    PS_BOOL_ENUM_UINT8 enDeframerDataLessEnable;    /* 解封装模块数据不足异常中断使能, 使能 - PS_TRUE */
    PS_BOOL_ENUM_UINT8 enDeframerDataMoreEnable;    /* 解封装模块数据过多异常中断使能, 使能 - PS_TRUE */
} HDLC_INTERRUPT_CFG_STRU;

/* HDLC配置相关信息结构 */
typedef struct
{
    VOS_UINT32                          ulHDLCIPBaseAddr;      /* 从底软获取的HDLC基地址 */
    VOS_UINT32                          ulHdlcDefMasterSem;    /* 解封装信号量 */
    VOS_UINT32                          ulHdlcFrmMasterSem;    /* 封装信号量 */
    VOS_INT32                           slHdlcISRDef;          /* 解封装中断号 */
    VOS_INT32                           slHdlcISRFrm;          /* 封装中断号 */
    VOS_UINT32                          ulHdlcDefIntLimit;     /* 解封装中断水线 */
    VOS_UINT32                          ulHdlcFrmIntLimit;     /* 封装中断水线 */
    HTIMER                              stHdlcFrmTimerHandle;  /* 申请封装目的空间失败定时器句柄 */
    VOS_UINT32                          ulHdlcMntnTraceCfg;    /* 可维可测等级配置 */
}HDLC_CONFIG_INFO_STRU;

extern HDLC_CONFIG_INFO_STRU                          g_stHdlcConfigInfo;
/*****************************************************************************
  8 UNION定义
*****************************************************************************/


/*****************************************************************************
  9 OTHERS定义
*****************************************************************************/


/*****************************************************************************
  10 函数声明
*****************************************************************************/
extern VOS_VOID link_HDLCInit(VOS_VOID);

extern VOS_VOID link_HDLCDisable(VOS_VOID);

extern VOS_UINT32 PPP_HDLC_HARD_Init(VOS_VOID);

extern VOS_VOID   PPP_HDLC_HARD_SetUp(PPP_ID usPppId);

extern VOS_VOID   PPP_HDLC_HARD_Disable(VOS_VOID);

extern PPP_HDLC_RESULT_TYPE_ENUM_UINT32 PPP_HDLC_HARD_ProcData
(
    PPP_ID usPppId,
    struct link *pstLink,
    PPP_ZC_QUEUE_STRU *pstDataQ
);

extern VOS_VOID PPP_HDLC_HARD_ProcProtocolPacket
(
    struct link     *pstLink,
    struct ppp_mbuf *pstMbuf,
    VOS_INT32       ulPri,
    VOS_UINT16      ulProtocol
);

extern VOS_VOID PPP_HDLC_HARD_ProcAsFrmPacket
(
    VOS_UINT16       usPppId,
    VOS_UINT16       usProtocol,
    PPP_ZC_STRU     *pstMem
);

extern VOS_UINT32 PPP_PHY_TO_VIRT(unsigned int ulPAddr);

extern VOS_UINT32 PPP_VIRT_TO_PHY(unsigned int ulVAddr);


#endif

#if ((VOS_OS_VER == VOS_WIN32) || (VOS_OS_VER == VOS_NUCLEUS))
#pragma pack()
#else
#pragma pack(0)
#endif

#ifdef __cplusplus
    #if __cplusplus
        }
    #endif
#endif


#endif /* end of hdlc_hardware.h */

